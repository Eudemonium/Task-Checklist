name: Create File-Friendly Release Source Archives

on:
  release:
    types: [published] 
  workflow_dispatch: 

jobs:
  build_source_archives:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'release' && github.event.release.tag_name || github.ref }}

      - name: Get Tag Name for Archives
        id: get_tag_name
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            echo "TAG_FOR_ARCHIVE=${{ github.event.release.tag_name }}" >> $GITHUB_ENV
          else
            RAW_REF_NAME=$(echo "${{ github.ref }}" | sed -e 's|refs/heads/||' -e 's|refs/tags/||')
            SANITIZED_REF_NAME=$(echo "${RAW_REF_NAME}" | sed 's/[^a-zA-Z0-9._-]/-/g')
            echo "TAG_FOR_ARCHIVE=${SANITIZED_REF_NAME:-manual-run}" >> $GITHUB_ENV
          fi

      - name: Define Archive Filenames
        id: set_filenames
        run: |
          echo "ARCHIVE_ZIP_NAME=Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.zip" >> $GITHUB_OUTPUT
          echo "ARCHIVE_TAR_NAME=Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.tar.gz" >> $GITHUB_OUTPUT
          echo "Generated Zip filename: Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.zip"
          echo "Generated Tar.gz filename: Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.tar.gz"

      - name: Create a staging directory for source files
        run: mkdir ./source_package_staging

      - name: Copy source files to staging directory
        run: |
          echo "Copying sources directory contents..."
          cp -r ./sources/* ./source_package_staging/
          echo "Copying root README.md if it exists..."
          if [ -f ./README.md ]; then cp ./README.md ./source_package_staging/; fi
          echo "Copying root LICENSE if it exists..."
          if [ -f ./LICENSE ]; then cp ./LICENSE ./source_package_staging/; fi
          echo "Listing staging directory contents:"
          ls -R ./source_package_staging

      - name: Prepare Critical CSS for injection
        id: prep_critical_css
        run: |
          CRITICAL_CSS_FILE="./source_package_staging/css/critical.css"
          INJECT_CONTENT=""
          if [ -f "$CRITICAL_CSS_FILE" ]; then
            CRITICAL_CSS_CONTENT=$(cat "$CRITICAL_CSS_FILE")
            # Prepare for multi-line environment variable
            INJECT_CONTENT=$(printf "<style type=\\"text/css\\">\n%s\n</style>" "${CRITICAL_CSS_CONTENT}")
            echo "Critical CSS prepared for injection."
          else
            echo "No critical.css found at $CRITICAL_CSS_FILE, critical CSS injection will be skipped or placeholder might remain."
          fi
          echo "INJECT_CRITICAL_CSS<<EOF" >> $GITHUB_ENV
          echo "${INJECT_CONTENT}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV


      - name: Inject Critical CSS into staged index.html (if critical CSS was prepared)
        working-directory: ./source_package_staging
        if: env.INJECT_CRITICAL_CSS != '' 
        run: |
          echo "Attempting to inject critical CSS into index.html..."
          if [ -f ./index.html ]; then
            TEMP_INDEX_HTML=$(mktemp)
            perl -0777 -pe 's|<%-\s*criticalCss\s*%>|${ENV::INJECT_CRITICAL_CSS}|sg' ./index.html > "$TEMP_INDEX_HTML" && mv "$TEMP_INDEX_HTML" ./index.html
            echo "Critical CSS injection attempt complete using perl."
          else
            echo "index.html not found in staging directory for CSS injection."
            exit 1
          fi
        env:
          INJECT_CRITICAL_CSS: ${{ env.INJECT_CRITICAL_CSS }}

      - name: Modify index.html for file:/// app.js compatibility (remove type=module)
        working-directory: ./source_package_staging
        run: |
          echo "Attempting to modify app.js script tag in index.html..."
          if [ -f ./index.html ]; then
            sed -i 's|<script type="module" src="js/app.js"|<script src="js/app.js"|g' ./index.html
            echo "app.js script tag modified in index.html."
          else
            echo "index.html not found in staging directory for JS modification."
          fi

      - name: Create Zip Archive of Modified Sources
        run: |
          cd ./source_package_staging
          zip -r ../${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }} .
          cd ..
          echo "Zip archive created: ${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }}"

      - name: Create Tar.gz Archive of Modified Sources
        run: |
          cd ./source_package_staging
          tar -czvf ../${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }} .
          cd ..
          echo "Tar.gz archive created: ${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }}"

      - name: List created archives 
        run: ls -l ./${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }} ./${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }}

      - name: Upload Zip Archive to Release with gh CLI
        if: github.event_name == 'release' && github.event.release.tag_name 
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME_FOR_UPLOAD: ${{ github.event.release.tag_name }} 
        run: |
          echo "Uploading Zip: ./${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }} to tag ${TAG_NAME_FOR_UPLOAD}"
          gh release upload "${TAG_NAME_FOR_UPLOAD}" ./"${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }}" --clobber

      - name: Upload Tar.gz Archive to Release with gh CLI
        if: github.event_name == 'release' && github.event.release.tag_name 
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME_FOR_UPLOAD: ${{ github.event.release.tag_name }}
        run: |
          echo "Uploading Tar.gz: ./${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }} to tag ${TAG_NAME_FOR_UPLOAD}"
          gh release upload "${TAG_NAME_FOR_UPLOAD}" ./"${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }}" --clobber
