name: Create File-Friendly Release Source Archives

on:
  release:
    types: [published] # Runs when a release is published
  workflow_dispatch: # Allows you to run this workflow manually from the Actions tab

jobs:
  build_source_archives:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for checkout (read) and to write release assets (write)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For 'release' trigger, checkout the specific tag.
          # For 'workflow_dispatch', it will checkout the branch you select (e.g., main).
          ref: ${{ github.event_name == 'release' && github.event.release.tag_name || github.ref }}

      - name: Get Tag Name for Archives
        id: get_tag_name
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            echo "TAG_FOR_ARCHIVE=${{ github.event.release.tag_name }}" >> $GITHUB_ENV
          else
            RAW_REF_NAME=$(echo "${{ github.ref }}" | sed -e 's|refs/heads/||' -e 's|refs/tags/||')
            SANITIZED_REF_NAME=$(echo "${RAW_REF_NAME}" | sed 's/[^a-zA-Z0-9._-]/-/g')
            echo "TAG_FOR_ARCHIVE=${SANITIZED_REF_NAME:-manual-run}" >> $GITHUB_ENV
          fi
        env:
          TAG_FOR_ARCHIVE: '' 

      - name: Define Archive Filenames
        id: set_filenames
        run: |
          echo "ARCHIVE_ZIP_NAME=Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.zip" >> $GITHUB_OUTPUT
          echo "ARCHIVE_TAR_NAME=Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.tar.gz" >> $GITHUB_OUTPUT
          echo "Generated Zip filename: Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.zip"
          echo "Generated Tar.gz filename: Task-Checklist-${{ env.TAG_FOR_ARCHIVE }}-Source.tar.gz"

      - name: Create a staging directory for source files
        run: mkdir ./source_package_staging

      - name: Copy source files to staging directory
        run: |
          echo "Copying sources directory contents..."
          cp -r ./sources/* ./source_package_staging/
          echo "Copying root README.md if it exists..."
          if [ -f ./README.md ]; then cp ./README.md ./source_package_staging/; fi
          echo "Copying root LICENSE if it exists..."
          if [ -f ./LICENSE ]; then cp ./LICENSE ./source_package_staging/; fi
          echo "Listing staging directory contents:"
          ls -R ./source_package_staging

      - name: Inject Critical CSS into staged index.html
        working-directory: ./source_package_staging
        run: |
          CRITICAL_CSS_FILE="./css/critical.css" # Path within source_package_staging
          INDEX_HTML_FILE="./index.html"
          PLACEHOLDER="<%- criticalCss %>" # The exact placeholder string in your sources/index.html

          if [ ! -f "$INDEX_HTML_FILE" ]; then
            echo "Error: $INDEX_HTML_FILE not found in staging directory."
            exit 1
          fi

          if [ -f "$CRITICAL_CSS_FILE" ]; then
            echo "Injecting critical CSS from $CRITICAL_CSS_FILE into $INDEX_HTML_FILE..."
            
            # Create the full style block to inject, saving to a temporary file
            CRITICAL_CSS_CONTENT=$(cat "$CRITICAL_CSS_FILE")
            STYLE_BLOCK_TEMP_FILE=$(mktemp)
            printf "<style type=\"text/css\">\n%s\n</style>" "${CRITICAL_CSS_CONTENT}" > "$STYLE_BLOCK_TEMP_FILE"
            
            # Use awk for robust replacement. It reads the placeholder and the style block.
            # It's generally safer for multi-line replacements with special characters.
            INDEX_HTML_TEMP_FILE=$(mktemp)
            awk -v placeholder="$PLACEHOLDER" -v style_file="$STYLE_BLOCK_TEMP_FILE" '
              BEGIN {
                # Read the entire style block from the temp file
                while ((getline line < style_file) > 0) {
                  style_block = style_block line "\n";
                }
                close(style_file);
                sub(/\n$/, "", style_block);
              }
              {
                gsub(placeholder, style_block);
                print;
              }
            ' "$INDEX_HTML_FILE" > "$INDEX_HTML_TEMP_FILE" && mv "$INDEX_HTML_TEMP_FILE" "$INDEX_HTML_FILE"

            rm "$STYLE_BLOCK_TEMP_FILE" # Clean up temp file
            echo "Critical CSS injected."
          else
            echo "Warning: $CRITICAL_CSS_FILE not found. Placeholder '$PLACEHOLDER' in $INDEX_HTML_FILE will not be replaced."
          fi

      - name: Modify index.html for file:/// app.js compatibility (remove type=module)
        working-directory: ./source_package_staging
        run: |
          echo "Attempting to modify app.js script tag in index.html..."
          if [ -f ./index.html ]; then
            sed -i 's|<script type="module" src="js/app.js"|<script src="js/app.js"|g' ./index.html
            echo "app.js script tag modified in index.html."
          else
            echo "index.html not found in staging directory for JS modification."
          fi

      - name: Create Zip Archive of Modified Sources
        run: |
          cd ./source_package_staging
          zip -r ../${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }} .
          cd ..
          echo "Zip archive created: ${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }}"

      - name: Create Tar.gz Archive of Modified Sources
        run: |
          cd ./source_package_staging
          tar -czvf ../${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }} .
          cd ..
          echo "Tar.gz archive created: ${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }}"

      - name: List created archives 
        run: ls -l ./${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }} ./${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }}

      - name: Upload Zip Archive to Release with gh CLI
        if: github.event_name == 'release' && github.event.release.tag_name 
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Uploading Zip: ./${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }} to tag ${{ github.event.release.tag_name }}"
          gh release upload "${{ github.event.release.tag_name }}" "./${{ steps.set_filenames.outputs.ARCHIVE_ZIP_NAME }}" --clobber

      - name: Upload Tar.gz Archive to Release with gh CLI
        if: github.event_name == 'release' && github.event.release.tag_name 
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Uploading Tar.gz: ./${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }} to tag ${{ github.event.release.tag_name }}"
          gh release upload "${{ github.event.release.tag_name }}" "./${{ steps.set_filenames.outputs.ARCHIVE_TAR_NAME }}" --clobber
